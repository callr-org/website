<%
<%-- Use RSP directives to identify current directory --%>
path <- dirname("<%@meta name="source"%>")
source(file.path(path, "printCode.R"))
%>

localenv <- environment()

<%----------------------------------------------------------------
 Importing from R.oo
 ----------------------------------------------------------------%>
trim <- <% printCode("trim", class="default", envir="R.oo") %>


<%----------------------------------------------------------------
 Importing from R.utils
 ----------------------------------------------------------------%>
isPackageInstalled <- <% printCode("isPackageInstalled", class="default", envir="R.utils") %>
findSourceTraceback <- <% printCode("findSourceTraceback", class="default", envir="R.utils") %>

<% for (name in c("captureOutput", "mprint", "mcat", "mstr", "mprintf")) { %>
<%=name%> <- <% printCode(name, envir="R.utils") %>
<% } # for (name ...) %>

# Create default debug output functions
for (name in c("mprint", "mcat", "mstr", "mprintf")) {
  dname <- sub("m", "d", name, fixed=TRUE)
  assign(dname, function(...) {})
}

setParameters <- function(params) {
  options(parameters=params)

  # Enable verbose output?
  if (hasParameter("verbose", TRUE)) {
    for (name in c("mprint", "mcat", "mstr", "mprintf")) {
      dname <- sub("m", "d", name, fixed=TRUE)
      assign(dname, get(name, mode="function"), envir=localenv)
    }
  }
} # setParameter()


hasParameter <- function(name, value=NULL) {
  params <- getOption("parameters", NULL)
  if (is.element(name, params)) return(FALSE)
  if (is.null(value)) return(TRUE)

  # Check if parameter has the requested value
  param <- params[[name]]

  # For logical values, allow for T, F, 1 and 0.
  if (mode(value) == "logical") {
    param <- switch(param, T=TRUE, F=FALSE, "1"=TRUE, "0"=FALSE, as.logical(param))
  }

  (param == value)
} # hasParameter()


hasUrlProtocol <- <% printCode("hasUrlProtocol", class="default", envir="R.utils") %>

# Parse URL
<%@include file="splitUrl.R"%>

parseUrl <- function() {
  # Don't assume 'utils' is attached
  URLdecode <- utils::URLdecode

  url <- getOption("debug_url")
  if (is.null(url)) {
    # Find all URL calls
    urls <- names(findSourceTraceback())
    pattern <- "^([abcdefghijklmnopqrstuvwxyz]+)(://)(.*)"
    urls <- grep(pattern, urls, value=TRUE)

    # Nothing found?
    if (length(urls) == 0L) return(list())

    # Use the most first one
    url <- urls[1L]
  }

  # Parse URL
  res <- splitUrl(url)

  # Set URL parameters globally
  setParameters(res$query_parsed)

  res
} # parseUrl()


<%----------------------------------------------------------------
 HISTORY:
 2014-09-20
 o Added support for URL parameter verbose=TRUE.
 o Added setParameters() and getParameter().
 2014-09-17
 o Now captureOutput() is also imported from R.utils.
 2014-09-03
 o Added splitUrl() and parseUrl().
 o Created. Now dynamically importing utility function from
   various source/packages.
 ----------------------------------------------------------------%>
